# 类模版

## 类模板与友元

- 当一个类包含一个友元时，类与友元各自是否为模板是相互无关的。如果一个类包含了一个非模板的友元，则友元被授权可以访问所有模板实例。 如果友元自己是模板，类可以授权给所有友元模板实例。
- 可以将模板参数声明为友元；
- 引用一个模板实例时需要先声明模板自身；

## 模板类的别名与类型成员

- 使用using可以为模板定义一个类型别名；
- 对于模板类的类型成员，编译器无法区分是静态变量还是类型，假定通过作用域运算符作用的是变量；当使用类型时使用`typename`标识；
  
## 成员函数模板

- 一个类（无论是否为模板类），都只可以是模板的成员函数，这种成员叫作成员模板。
- 成员模板不可以是虚函数。
- 普通类的成员模板跟函数模板相同
- 类模板与成员模板其模板参数独立，在类模板外定义一个成员模版时需要同时提供类模板参数和成员模板参数；类模板的参数列表在前，成员模板的模板参数在后

## 别名模板

```C++
template<typename T>
using myvec = std::vector<T, allocator<T>>;
template<template<typename T> class Continaer>
class Test {
};
Test<myvec> test;
```

# 模板参数

- 对于模板参数，即可以为类型，也可以为非类型参数，也可以为模板类。
- 可以是指针也可以是引用
- 支持默认参数类型

# 模板实参的推断

- 指的是函数模板中根据实参类型进行推断形参
- 只有两种类型转换(隐式转换)，不允许算数类型转换和派生类到基类的转换，用户定义的转换等
  - const 转换，一个非const 对象的引用或指针的实参可以传递给一个const的引用或指针的形参。
  - 如果函数不是引用类型（当是引用类型时，数组的大小不一样，类型不同）时，数组转换为指针，函数转换为函数指针
- 对于普通类型的参数是可以转换的，正常的类型转换也可以应用于显示指定的实参的
- 当我们使用一个函数模板初始化一个函数指针时，编译器会使用函数指针的类型来推断模板实参的
- 如果一个函数模板参数为右值引用，则可以传递给它任意类型的实参
- 当模板参数为左值引用时，只能传递给它的一个左值的实参；当模板参数为const 左值引用时，传递给它的一个左值的实参/临时对象、字面值等

# 模板的实例化

- 实例化时编译器才生成代码，相同的实例可能出现在多个对象文件中
- 显示实例化：`extern template declaration(类或函数声明)`
- 实例化定义：`template declaration`
- 在实例化的声明与定义之前，都应该已经定义好了模板类或者模板函数，否则编译报错
- 当编译器遇到extern时，不会在本文件中生成实例化的代码，表示了在程序的其它位置有该实例化。
- 一个类模板的实例化定义会实例化所有的成员函数

# 模板的特例化

- 实例化编译器会生成相应实例代码，编译器优先使用特例模板
- 全特例化：所有形参都特例化
- 部分特例化：类模板可以部分特例化，函数模板不可以部分特例化；特例化一部分参数和特例化参数的一部分